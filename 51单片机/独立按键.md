## 独立按键

### 简介

​		按键管脚两端距离长的表示默认是导通状态, 距离短的默认是断开状态, 如果按键按下, 初始导通状态变为断开, 初始断开状态变为导通.

​											![QQ截图20211107101006](E:\markdown\51单片机\pics\QQ截图20211107101006.png)<img src="E:\markdown\51单片机\pics\Untitled.png" alt="Untitled" style="zoom: 50%;" />

​		由于机械点的弹性作用，按键开关在闭合时不会马上稳定的接通，在断开时也不会一下子断开，因而在闭合和断开的瞬间均伴随着一连串的抖动。抖动时间的长短由按键的机械特性决定的，**一般为 5ms 到 10ms**。按键稳定闭合时间的长短则由操作人员的按键动作决定的，一般为零点几秒至数秒。按键抖动会引起按键被误读多次。为了确保 CPU 对按键的一次闭合仅作一次处理，必须进行**消抖**。

​		按键消抖有两种方式，一种是硬件消抖，另一种是软件消抖。

### 软件消抖

1. 先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻，所以默认 IO 为高电平）。 

2. 读取 IO 口电平确认是否有按键按下。 

3. 如有 IO 电平为低电平后，延时几个毫秒。 

4. 再读取该 IO 电平，如果仍然为低电平，说明按键按下。 

5. 执行按键控制程序。

### 硬件设计

<img src="E:\markdown\51单片机\pics\QQ截图20211107101348.png" alt="QQ截图20211107101348" style="zoom:50%;" />

​		从上图中可以看出，4 个独立按键的控制管脚连接到 51 单片机的 P3.0-P3.3脚上。其中 K1 连接在 P3.1 上，K2 连接在 P3.0 上，K3 连接在 P3.2 上，K4 连接在 P3.3 上。4 个按键另一端全部连接在 GND，当按键按下后，对应 IO 口即为低电平.

### 代码

```c
#include "public.h"
#define KEY1_PRESS 1
#define KEY2_PRESS 2
#define KEY3_PRESS 3
#define KEY4_PRESS 4
#define KEY_UNPRESS 0

//定义独立按键控制脚
sbit KEY1 = P3 ^ 1;
sbit KEY2 = P3 ^ 0;
sbit KEY3 = P3 ^ 2;
sbit KEY4 = P3 ^ 3;

//定义LED1控制脚
sbit LED1 = P2 ^ 0;

u8 key_scan(u8 mode) {
    static u8 key = 1;
    //连续扫描按键
    if (mode)
        key = 1;
    if (key == 1 && (KEY1 == 0 || KEY2 == 0 || KEY3 == 0 || KEY4 == 0)) {
        //消抖
        delay_10us(1000);
        key = 0;
        if (KEY1 == 0)
            return KEY1_PRESS;
        else if (KEY2 == 0) {
            return KEY2_PRESS;
        } else if (KEY3 == 0) {
            return KEY3_PRESS;
        } else if (KEY4 == 0) {
            return KEY4_PRESS;
        }
    } else if (KEY1 == 1 && KEY2 == 1 && KEY3 == 1 && KEY4 == 1) {
        //无按键按下
        key = 1;
    }
    return KEY_UNPRESS;
}

void main() {
    u8 key = 0;
    while (1) {
        key = key_scan(0);
        if (key == KEY1_PRESS)
            LED1 = !LED1;
    }
}
```

### 实验现象

​	按下独立按键的第一个按钮, LED第一个灯的状态取反.