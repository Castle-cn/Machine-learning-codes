## 矩阵按键

![QQ截图20211105160530](E:\markdown\51单片机\pics\QQ截图20211105160530.png)

​		开发板上将 16 个按键排成 4 行 4 列，第一行将每个按键的一端连接在一起构成行线，第一列将每个按键的另一端连接在一起构成列线，这样便一共有 4 行 4 列共 8 根线，我们将这 8 根线连接到单片机的 8 个 I/O 口上，通过程序扫描键盘就可检测 16 个键。用这种方法我们也可实现 3 行 3 列 9 个键、 5 行 5 列 25 个键、 6 行 6 列 36 个键甚至更多。 



### 检测方法

​		无论是独立键盘还是矩阵键盘，单片机检测其是否被按下的依据都是一样 的，也就是检测与该键对应的 I/O 口是否为低电平。

​		矩阵键盘两端都与单片机 I/O 口相连，因此在检测时需编程通过单片机 I/O 口送出低电平。检测方法有多种，最常用的是**行列扫描**和**线翻转法**。

 

**行列扫描法**

​		行列扫描法检测时，先送一列为低电平，其余几列全为高电平(此时我们确定了列数)，然后立即轮流检测一次各行是否有低电平，若检测到某一行为低电平(这时我们又确定了行数)，则我们便可确认当前被按下的键是哪一行哪一列的，用同样方法轮流送各列一次低电平，再轮流检测一次各行是否变为低电平，这样即可检测完所有的按键，当有键被按下时便可判断出按下的键是哪一个键。当然我们也可以将行线置低电平，扫描列是否有低电平。从而达到整个键盘的检测

```c
/**
 * @brief 使用行列式扫描方法，检测矩阵按键是否按下，按下则返回对应键值
 * @return key_value：1-16，对应 S1-S16 键
 */
u8 key_matrix_ranks_scan(void) {
    u8 key_value = 0;
    u16 i;

    KEY_MATRIX_PORT = 0xf7;
    if (KEY_MATRIX_PORT != 0xf7) {
        delay_10us(1000);  //消抖
        switch (KEY_MATRIX_PORT) {
            case 0x77:
                key_value = 1;
                break;
            case 0xb7:
                key_value = 5;
                break;
            case 0xd7:
                key_value = 9;
                break;
            case 0xe7:
                key_value = 13;
                break;
        }
    }
    while (KEY_MATRIX_PORT != 0xf7) {
    }

    KEY_MATRIX_PORT = 0xfb;  //给第二列赋值 0，其余全为 1
    if (KEY_MATRIX_PORT != 0xfb) {
        delay_10us(1000);         //消抖
        switch (KEY_MATRIX_PORT)  //保存第二列按键按下后的键值
        {
            case 0x7b:
                key_value = 2;
                break;
            case 0xbb:
                key_value = 6;
                break;
            case 0xdb:
                key_value = 10;
                break;
            case 0xeb:
                key_value = 14;
                break;
        }
    }
    while (KEY_MATRIX_PORT != 0xfb) {
    }

    KEY_MATRIX_PORT = 0xfd;
    if (KEY_MATRIX_PORT != 0xfd) {
        delay_10us(1000);         //消抖
        switch (KEY_MATRIX_PORT)  //保存第三列按键按下后的键值
        {
            case 0x7d:
                key_value = 3;
                break;
            case 0xbd:
                key_value = 7;
                break;
            case 0xdd:
                key_value = 11;
                break;
            case 0xed:
                key_value = 15;
                break;
        }
    }
    while (KEY_MATRIX_PORT != 0xfd) {
    }

    KEY_MATRIX_PORT = 0xfe;
    if (KEY_MATRIX_PORT != 0xfe) {
        delay_10us(1000);
        switch (KEY_MATRIX_PORT) {
            case 0x7e:
                key_value = 4;
                break;
            case 0xbe:
                key_value = 8;
                break;
            case 0xde:
                key_value = 12;
                break;
            case 0xee:
                key_value = 16;
                break;
        }
    }
    while (KEY_MATRIX_PORT != 0xfe) {
    }

    return key_value;
}
```



**线翻转法**

​		使所有行线为低电平时，检测所有列线是否有低电平，如果有，就记录列线值；然后再翻转，使所有列线都为低电平，检测所有行线的值，由于有按键按下，行线的值也会有变化，记录行线的值。从而就可以检测到全部按键。

```c
u8 key_matrix_flip_scan(void) {
    static u8 key_value = 0;

    KEY_MATRIX_PORT = 0x0f;       //给所有行赋值0，列全为1
    if (KEY_MATRIX_PORT != 0x0f)  //判断按键是否按下
    {
        delay_10us(1000);  //消抖
        if (KEY_MATRIX_PORT != 0x0f) {
            //测试列
            KEY_MATRIX_PORT = 0x0f;
            switch (KEY_MATRIX_PORT)  //保存行为0，按键按下后的列值
            {
                case 0x07:
                    key_value = 1;
                    break;
                case 0x0b:
                    key_value = 2;
                    break;
                case 0x0d:
                    key_value = 3;
                    break;
                case 0x0e:
                    key_value = 4;
                    break;
            }
            //测试行
            KEY_MATRIX_PORT = 0xf0;
            switch (KEY_MATRIX_PORT)  //保存列为0，按键按下后的键值
            {
                case 0x70:
                    key_value = key_value;
                    break;
                case 0xb0:
                    key_value = key_value + 4;
                    break;
                case 0xd0:
                    key_value = key_value + 8;
                    break;
                case 0xe0:
                    key_value = key_value + 12;
                    break;
            }
            while (KEY_MATRIX_PORT != 0xf0)
                ;  //等待按键松开
        }
    } else
        key_value = 0;

    return key_value;
}
```



### 实验代码

​		矩阵键盘第一行对应 0-3, 第二行对应 4-7, 第三行对应 8-B, 第四行对应 C-F, 按下按键, 数码管静态显示对应数字

```c
#include "button_matrix.h"
#include "public.h"
#define SMG_A_DP_PORT P0

u8 gsmg_code[16] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
                    0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71};

void main() {
    u16 key = 0;
    while (1) {
        key = key_matrix_flip_scan();
        if(key){
            SMG_A_DP_PORT = gsmg_code[key - 1];
        }
    }
}
```

